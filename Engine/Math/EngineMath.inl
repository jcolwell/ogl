//======================================================================================
// Includes
//======================================================================================
#include <Utilities.h>

#include "Vector2.h"
//======================================================================================

//======================================================================================
// NAMESPACE Math
//======================================================================================
namespace Math
{

//======================================================================================
// Function Declarations
//======================================================================================

template <typename T>
inline T Min(T a, T b)
{
	return (a > b) ? b : a;
}

//--------------------------------------------------------------------------------------

template <typename T>
inline T Max(T a, T b)
{
	return (a > b) ? a : b;
}

//--------------------------------------------------------------------------------------

template <typename T>
inline T Clamp(T value, T min, T max)
{
	return Max(min, Min(max, value));
}

//--------------------------------------------------------------------------------------

inline f32 Abs(f32 value)
{
	return (value >= 0.0f) ? value : -value;
}

//--------------------------------------------------------------------------------------

inline f32 Sign(f32 value)
{
	return (value > 0.0f) ? 1.0f : -1.0f;
}

//--------------------------------------------------------------------------------------

inline f32 Sqr(f32 value)
{
	return value * value;
}

//--------------------------------------------------------------------------------------

inline f32 Sqrt(f32 value)
{
	//https://en.wikipedia.org/wiki/Fast_inverse_square_root
	const f32 threehalfs = 1.5f;

	f32 x2 = value * 0.5F;
	f32 y = value;
	u32 i = *(u32*)&y;
	i = 0x5f3759df - (i >> 1);
	y = *(f32 *)&i;
	y = y * (threehalfs - (x2 * y * y));


	return y;
}

//--------------------------------------------------------------------------------------

bool Compare(f32 a, f32 b, f32 epsilon = 0.0001)
{
	return Abs(a - b) < epsilon;
}

//--------------------------------------------------------------------------------------

bool IsZero(f32 value)
{
	return Compare(value, 0.0f);
}

//--------------------------------------------------------------------------------------

bool IsZero(const Vector2 & v)
{
	return IsZero(v.x) && IsZero(v.y);
}

//--------------------------------------------------------------------------------------

//bool IsZero(const Vector3 & v)
//{
//	return IsZero(v.x) && IsZero(v.y) && IsZero(v.z);
//}

//--------------------------------------------------------------------------------------

inline f32 MagnitudeSqr(const Vector2 &v)
{
	return Sqr(v.x) + Sqr(v.y);
}

//--------------------------------------------------------------------------------------

//inline f32 MagnitudeSqr(const Vector3& v)
//{
//	return Sqr(v.x) + Sqr(v.y) + Sqr(v.z);
//}

//--------------------------------------------------------------------------------------

inline f32 Magnitude(const Vector2& v)
{
	return Sqrt(MagnitudeSqr(v));
}

//--------------------------------------------------------------------------------------

//inline f32 Magnitude(const Vector3& v)
//{
//	return Sqrt(MagnitudeSqr(v));
//}

//--------------------------------------------------------------------------------------

//inline f32 MagnitudeXZSqr(const Vector3& v)
//{
//	return (v.x * v.x) + (v.z * v.z);
//}

//--------------------------------------------------------------------------------------

//inline f32 MagnitudeXZ(const Vector3& v)
//{
//	return Sqrt(MagnitudeXZSqr(v));
//}

//--------------------------------------------------------------------------------------

inline Vector2 Normalize(const Vector2& v)
{
	ASSERT(!IsZero(v), "[Math] Cannot normalize the zero vector");
	const f32 inv = 1.0f / Magnitude(v);
	return v * inv;
}

//--------------------------------------------------------------------------------------

//inline Vector3 Normalize(const Vector3& v)
//{
//	assert(!IsZero(v) && "[Math] Cannot normalize the zero vector");
//	const f32 inv = 1.0f / Magnitude(v);
//	return v * inv;
//}

//--------------------------------------------------------------------------------------

inline f32 DistanceSqr(const Vector2& a, const Vector2& b)
{
	return MagnitudeSqr(a - b);
}

//--------------------------------------------------------------------------------------

//inline f32 DistanceSqr(const Vector3& a, const Vector3& b)
//{
//	return MagnitudeSqr(a - b);
//}

//--------------------------------------------------------------------------------------

inline f32 Distance(const Vector2& a, const Vector2& b)
{
	return Magnitude(a - b);
}

//--------------------------------------------------------------------------------------

//inline f32 Distance(const Vector3& a, const Vector3& b)
//{
//	return Magnitude(a - b);
//}

//--------------------------------------------------------------------------------------

//inline f32 DistanceXZSqr(const Vector3& a, const Vector3& b)
//{
//	return MagnitudeXZSqr(a - b);
//}

//--------------------------------------------------------------------------------------

//inline f32 DistanceXZ(const Vector3& a, const Vector3& b)
//{
//	return MagnitudeXZ(a - b);
//}

//--------------------------------------------------------------------------------------

//inline f32 Dot(const Vector3& a, const Vector3& b)
//{
//	return (a.x * b.x) + (a.y * b.y) + (a.z * b.z);
//}

//--------------------------------------------------------------------------------------

//inline Vector3 Cross(const Vector3& a, const Vector3& b)
//{
//	return Vector3
//	(
//		(a.y * b.z) - (a.z * b.y),
//		(a.z * b.x) - (a.x * b.z),
//		(a.x * b.y) - (a.y * b.x)
//	);
//}

//--------------------------------------------------------------------------------------

//inline Vector3 Project(const Vector3& v, const Vector3& n)
//{
//	return n * (Dot(v, n) / Dot(n, n));
//}

//--------------------------------------------------------------------------------------

//inline f32 Determinant(const Matrix& m)
//{
//	f32 det = 0.0f;
//	det += (m._11) * ((m._22 * m._33 * m._44) + (m._32 * m._43 * m._21) + (m._42 * m._23 * m._34) - (m._42 * m._33 * m._24) - (m._22 * m._43 * m._34) - (m._44 * m._23 * m._32));
//	det -= (m._12) * ((m._21 * m._33 * m._44) + (m._34 * m._43 * m._21) + (m._41 * m._23 * m._34) - (m._42 * m._33 * m._41) - (m._34 * m._43 * m._21) - (m._44 * m._23 * m._31));
//	det += (m._13) * ((m._21 * m._32 * m._44) + (m._31 * m._44 * m._21) + (m._41 * m._22 * m._34) - (m._42 * m._32 * m._41) - (m._34 * m._42 * m._21) - (m._44 * m._22 * m._31));
//	det -= (m._14) * ((m._21 * m._32 * m._43) + (m._31 * m._44 * m._23) + (m._41 * m._22 * m._33) - (m._23 * m._32 * m._41) - (m._33 * m._42 * m._21) - (m._43 * m._22 * m._31));
//	return det;
//}

//--------------------------------------------------------------------------------------

//@ToCheck: This matrix may be transposed...
//inline Matrix Adjoint(const Matrix& m)
//{
//	return Matrix
//	(
//		(m._22 * ((m._33 * m._44) - (m._43 * m._34)) - m._23 * ((m._32 * m._44) - (m._42 * m._34)) + m._24 * ((m._32 * m._43) - (m._42 * m._33))),
//		-(m._12 * ((m._33 * m._44) - (m._43 * m._34)) - m._13 * ((m._32 * m._44) - (m._42 * m._34)) + m._14 * ((m._32 * m._43) - (m._42 * m._33))),
//		(m._12 * ((m._23 * m._44) - (m._43 * m._24)) - m._13 * ((m._22 * m._44) - (m._42 * m._24)) + m._14 * ((m._22 * m._43) - (m._42 * m._23))),
//		-(m._12 * ((m._23 * m._34) - (m._33 * m._24)) - m._13 * ((m._22 * m._34) - (m._32 * m._24)) + m._14 * ((m._22 * m._33) - (m._32 * m._23))),
//
//		-(m._21 * ((m._33 * m._44) - (m._43 * m._34)) - m._31 * ((m._23 * m._44) - (m._24 * m._43)) + m._41 * ((m._23 * m._34) - (m._24 * m._33))),
//		(m._11 * ((m._33 * m._44) - (m._43 * m._34)) - m._13 * ((m._31 * m._44) - (m._41 * m._34)) + m._14 * ((m._31 * m._43) - (m._41 * m._33))),
//		-(m._11 * ((m._23 * m._44) - (m._43 * m._24)) - m._13 * ((m._21 * m._44) - (m._41 * m._24)) + m._14 * ((m._21 * m._43) - (m._41 * m._23))),
//		(m._11 * ((m._23 * m._34) - (m._33 * m._24)) - m._13 * ((m._21 * m._34) - (m._31 * m._24)) + m._14 * ((m._21 * m._33) - (m._31 * m._23))),
//
//		(m._21 * ((m._32 * m._44) - (m._42 * m._34)) - m._31 * ((m._22 * m._44) - (m._42 * m._24)) + m._41 * ((m._22 * m._34) - (m._32 * m._24))),
//		-(m._11 * ((m._32 * m._44) - (m._42 * m._34)) - m._31 * ((m._12 * m._44) - (m._42 * m._14)) + m._41 * ((m._12 * m._34) - (m._32 * m._14))),
//		(m._11 * ((m._22 * m._44) - (m._42 * m._24)) - m._12 * ((m._21 * m._44) - (m._41 * m._24)) + m._14 * ((m._21 * m._42) - (m._41 * m._22))),
//		-(m._11 * ((m._22 * m._34) - (m._32 * m._24)) - m._21 * ((m._12 * m._34) - (m._32 * m._14)) + m._31 * ((m._12 * m._24) - (m._22 * m._14))),
//
//		-(m._21 * ((m._32 * m._43) - (m._42 * m._33)) - m._31 * ((m._22 * m._43) - (m._42 * m._23)) + m._41 * ((m._22 * m._33) - (m._32 * m._23))),
//		(m._11 * ((m._32 * m._43) - (m._42 * m._33)) - m._12 * ((m._31 * m._43) - (m._41 * m._33)) + m._13 * ((m._31 * m._42) - (m._41 * m._32))),
//		-(m._11 * ((m._22 * m._43) - (m._42 * m._23)) - m._12 * ((m._21 * m._43) - (m._41 * m._23)) + m._13 * ((m._21 * m._42) - (m._41 * m._22))),
//		(m._11 * ((m._22 * m._33) - (m._32 * m._23)) - m._12 * ((m._21 * m._33) - (m._31 * m._23)) + m._13 * ((m._21 * m._32) - (m._31 * m._22)))
//	);
//}

//--------------------------------------------------------------------------------------

//inline Matrix Inverse(const Matrix& m)
//{
//	const f32 determinat = Determinant(m);
//	assert(!IsZero(determinat) && "[Math] Cannot find inverse of matrix. Determinant equals 0.0!");
//	const f32 invDet = 1.0f / determinat;
//	return Adjoint(m) * invDet;
//}

//--------------------------------------------------------------------------------------

//inline Matrix Transpose(const Matrix& m)
//{
//	return Matrix
//	(
//		m._11, m._12, m._13, m._14,
//		m._21, m._22, m._23, m._42,
//		m._31, m._32, m._33, m._34,
//		m._41, m._42, m._43, m._44
//	);
//}

//--------------------------------------------------------------------------------------

//inline Vector3 TransformCoord(const Vector3& v, const Matrix& m)
//{
//	return Vector3
//	(
//		v.x * m._11 + v.y * m._12 + v.z * m._14 + m._14,
//		v.x * m._21 + v.y * m._22 + v.z * m._24 + m._24,
//		v.x * m._31 + v.y * m._32 + v.z * m._34 + m._34
//	);
//}

//--------------------------------------------------------------------------------------

//inline Vector3 TransformNormal(const Vector3& v, const Matrix& m)
//{
//	return Vector3
//	(
//		v.x * m._11 + v.y * m._12 + v.z * m._14,
//		v.x * m._21 + v.y * m._22 + v.z * m._24,
//		v.x * m._31 + v.y * m._32 + v.z * m._34
//	);
//}

//--------------------------------------------------------------------------------------

inline Vector2 Lerp(const Vector2& v0, const Vector2& v1, f32 t)
{
	return v0 + ((v1 - v0) * t);
}

//--------------------------------------------------------------------------------------

//inline Vector3 Lerp(const Vector3& v0, const Vector3& v1, f32 t)
//{
//	return v0 + ((v1 - v0) * t);
//}

//--------------------------------------------------------------------------------------


} // namespace math